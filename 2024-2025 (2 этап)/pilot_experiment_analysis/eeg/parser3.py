# -*- coding: utf-8 -*-
"""parser3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1caB1PRAcYvyAww3VVVkDrS1uDSjHAVzf
"""

import pandas as pd
import os

# Папка с метками
archive = 'CB.xlsx'

# Папка с участниками
data = 'CB Markers'

# Папка с обновлёнными данными участников, if None - расположение то же где и участник, иначе в другой папке любой
data_up = 'New_Data'
if not os.path.exists(data_up):
    os.makedirs(data_up)

def convert_IAT4(IAT4):
    # Кодирует IAT4 численно в виде двух переменных cb и cbv
    parts = IAT4.split('_')
    if len(parts) == 1:
        cb_value = 0
        cbv_value = 0
    elif len(parts) == 2:
        cb_mapping = {'neutral': 0, 'match': 1, 'mismatch': 2}
        cbv_mapping = {'neutral': 0, 'negative': 1, 'positive': 2}
        cb_value = cb_mapping.get(parts[0], -1)
        cbv_value = cbv_mapping.get(parts[1], -1)
    else:
        print("Неверный формат строки IAT4")
        return None, None
    return cb_value, cbv_value


CB_df = pd.read_excel(archive)
# Перебираем участников
for participant_id in os.listdir(data):
    participant_folder = os.path.join(data, participant_id)
    if os.path.isdir(participant_folder):

        main_file_path = os.path.join(participant_folder, f"{participant_id}_Main.csv")
        if not os.path.exists(main_file_path):
             print(f'Не существует Main файла {participant_id}')
             continue
        main_df = pd.read_csv(main_file_path, header=None)

        #Если не найден ID участника в CB файле то скипаем участника
        if CB_df.loc[(CB_df['ID'].str[-5:] == participant_id)].empty:
            print(f'Не найден {participant_id} в {archive}')
            continue

        # Считываем переменные IAT4 и ROW_NUM из archive в случае совпадения ID
        # Строки с переменными уже упорядочены нужным образом
        IAT4 = CB_df.loc[(CB_df['ID'].str[-5:] == participant_id), 'CB_IAT4'].values
        ROW_NUM = CB_df.loc[(CB_df['ID'].str[-5:] == participant_id), 'Row_num'].values

        # Итерируемся по переменным которые хотим загрузить и по строкам файла участника
        count = 0
        for index, row in main_df.iterrows():

            # Вставка
            cb_value, cbv_value = convert_IAT4(IAT4[count])
            insertion_str = f"cb{cb_value}cbv{cbv_value}rn{ROW_NUM[count]}"

            for key in ['bmain', 'emain', 'bansmain', 'eansmain']:
                if key in row[5]:
                    main_df.at[index, 5] = row[5].replace(key, f'{key+insertion_str}')

            # Добавляем не только вставку но и Ef в конце т.к. такой метки не было а число было
            for key in  ['none', 'tar', 'pone', 'ptwo', 'pthree', 'nthree', 'ntwo']:
                if key in row[5]:
                    main_df.at[index, 5] = row[5].replace(key, f'{key+insertion_str}Ef')

            # Когда трайл(?) заканчивается то заполняем следующий трайл начиная с bmain будем заполнять обновлёнными переменными
            if 'eansmain' in row[5]:
                count+=1

        # save обновлённый файл участника
        main_df.to_csv(os.path.join(data_up, f'{participant_id}_main_modified.csv'), index=False, header=None)